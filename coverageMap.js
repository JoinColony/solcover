
/**
 * This file contains methods that produce a coverage map to pass to instanbul
 * from data generated by `instrumentSolidity.js`
 */
const SolidityCoder = require('web3/lib/solidity/coder.js');
const path = require('path');
const keccak = require('keccakjs');

/**
 * Converts solcover event data into an object that can be
 * be passed to instanbul to produce coverage reports.
 * @type {CoverageMap}
 */
module.exports = class CoverageMap {

  constructor() {
    this.coverage = {};
    this.lineTopics = [];
    this.functionTopics = [];
    this.branchTopics = [];
    this.statementTopics = [];
  }

  /**
   * Initializes a coverage map object for contract instrumented per `info` and located
   * at `canonicalContractPath`
   * @param {Object} info `info = getIntrumentedVersion(contract, fileName, true)`
   * @param {String} canonicalContractPath target file location
   * @return {Object} coverage map with all values set to zero
   */

  addContract(info, canonicalContractPath) {
    this.coverage[canonicalContractPath] = {
      l: {},
      path: canonicalContractPath,
      s: {},
      b: {},
      f: {},
      fnMap: {},
      statementMap: {},
      branchMap: {},
    };

    info.runnableLines.forEach((item, idx) => {
      this.coverage[canonicalContractPath].l[info.runnableLines[idx]] = 0;
    });
    this.coverage[canonicalContractPath].fnMap = info.fnMap;
    for (let x = 1; x <= Object.keys(info.fnMap).length; x++) {
      this.coverage[canonicalContractPath].f[x] = 0;
    }
    this.coverage[canonicalContractPath].branchMap = info.branchMap;
    for (let x = 1; x <= Object.keys(info.branchMap).length; x++) {
      this.coverage[canonicalContractPath].b[x] = [0, 0];
    }
    this.coverage[canonicalContractPath].statementMap = info.statementMap;
    for (let x = 1; x <= Object.keys(info.statementMap).length; x++) {
      this.coverage[canonicalContractPath].s[x] = 0;
    }

    const keccakhex = (x => {
      const hash = new keccak(256); // eslint-disable-line new-cap
      hash.update(x);
      return hash.digest('hex');
    });

    this.lineTopics.push(keccakhex('__Coverage' + info.contractName + '(string,uint256)'));
    this.functionTopics.push(keccakhex('__FunctionCoverage' + info.contractName + '(string,uint256)'));
    this.branchTopics.push(keccakhex('__BranchCoverage' + info.contractName + '(string,uint256,uint256)'));
    this.statementTopics.push(keccakhex('__StatementCoverage' + info.contractName + '(string,uint256)'));
  }

  /**
   * Populates an empty coverage map with values derived from an array of events
   * fired by instrumented contracts as they are tested
   * @param  {Array} events
   * @param  {String} relative path to host contracts eg: './../contracts'
   * @return {Object} coverage map.
   */
  generate(events, pathPrefix) {
    for (let idx = 0; idx < events.length; idx++) {
      const event = JSON.parse(events[idx]);

      if (event.topics.filter(t => this.lineTopics.indexOf(t) >= 0).length > 0) {
        const data = SolidityCoder.decodeParams(['string', 'uint256'], event.data.replace('0x', ''));
        const canonicalContractPath = data[0];
        this.coverage[canonicalContractPath].l[data[1].toNumber()] += 1;
      } else if (event.topics.filter(t => this.functionTopics.indexOf(t) >= 0).length > 0) {
        const data = SolidityCoder.decodeParams(['string', 'uint256'], event.data.replace('0x', ''));
        const canonicalContractPath = data[0];
        this.coverage[canonicalContractPath].f[data[1].toNumber()] += 1;
      } else if (event.topics.filter(t => this.branchTopics.indexOf(t) >= 0).length > 0) {
        const data = SolidityCoder.decodeParams(['string', 'uint256', 'uint256'], event.data.replace('0x', ''));
        const canonicalContractPath = data[0];
        this.coverage[canonicalContractPath].b[data[1].toNumber()][data[2].toNumber()] += 1;
      } else if (event.topics.filter(t => this.statementTopics.indexOf(t) >= 0).length > 0) {
        const data = SolidityCoder.decodeParams(['string', 'uint256'], event.data.replace('0x', ''));
        const canonicalContractPath = data[0];
        this.coverage[canonicalContractPath].s[data[1].toNumber()] += 1;
      }
    }
    return Object.assign({}, this.coverage);
  }
};
